package crystal.addons.modules;

import crystal.addons.CrystalCL;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.utils.entity.SortPriority;
import meteordevelopment.meteorclient.utils.entity.TargetUtils;
import meteordevelopment.meteorclient.utils.player.InvUtils;
import meteordevelopment.meteorclient.utils.world.BlockUtils;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.block.Blocks;
import net.minecraft.block.ShapeContext;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.Items;
import net.minecraft.item.PotionItem;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;

import java.util.List;

public class CityExploit extends Module {
    private final SettingGroup sgGeneral = settings.createGroup("Exploit");
    private final SettingGroup sgPause = settings.createGroup("Pause");
    private final Setting<Mode> mode = sgGeneral.add(new EnumSetting.Builder<Mode>().name("Mode").description("The mode of CityExploit.").defaultValue(Mode.Button).build());
    private final Setting<Integer> range = sgGeneral.add(new IntSetting.Builder().name("range").description("The radius players can be in to be targeted.").defaultValue(5).sliderMin(0).sliderMax(10).build());
    private final Setting<Integer> Pdelay = sgGeneral.add(new IntSetting.Builder().name("delay").description("How many ticks between block placements.").defaultValue(1).sliderMin(0).sliderMax(10).build());
    private final Setting<Boolean> pauseOnEat = sgPause.add(new BoolSetting.Builder().name("pause-on-eat").description("Pauses while eating.").defaultValue(false).build());
    private final Setting<Boolean> pauseOnDrink = sgPause.add(new BoolSetting.Builder().name("pause-on-drink").description("Pauses while drinking potions.").defaultValue(false).build());
    private final Setting<Boolean> pauseOnMine = sgPause.add(new BoolSetting.Builder().name("pause-on-mine").description("Pauses while mining blocks.").defaultValue(false).build());
    private final Setting<Boolean> rotate = sgGeneral.add(new BoolSetting.Builder().name("rotate").description("Sends rotation packets to the server when placing.").defaultValue(false).build());

    private PlayerEntity target = null;
    private List<BlockPos> placePositions;
    private List<BlockPos> placePositionsB;
    private boolean placed;
    private int delay;

    public CityExploit() {
        super(CrystalCL.Exc, "city-exploit", "Prevents the enemy from building up in the sarround");
    }

    @EventHandler
    private void onTick(TickEvent.Pre event) {
        int tnt;
        if (mode.get() == Mode.TnT) {
            target = TargetUtils.getPlayerTarget(range.get(), SortPriority.LowestDistance);
            if (target == null || mc.player.distanceTo(target) > (float) range.get()) {
                return;
            }

            placed = false;
            placePositions.clear();
            tnt = InvUtils.findInHotbar(Items.TNT).getSlot();
            int fire = InvUtils.findInHotbar(Items.FLINT_AND_STEEL).getSlot();
            if (fire == -1) {
                fire = InvUtils.findInHotbar(Items.FIRE_CHARGE).getSlot();
            }

            if (tnt == -1 || fire == -1) {
                return;
            }

            if (mc.player.isUsingItem() && (mc.player.getMainHandStack().getItem().isFood() || mc.player.getOffHandStack().getItem().isFood()) && pauseOnEat.get() || mc.interactionManager.isBreakingBlock() && pauseOnMine.get() || mc.player.isUsingItem() && (mc.player.getMainHandStack().getItem() instanceof PotionItem || mc.player.getOffHandStack().getItem() instanceof PotionItem) && pauseOnDrink.get()) {
                return;
            }

            findPlacePos(target);

            for (int x = 0; x < placePositions.size(); x++) {
                BlockPos blockPos = placePositions.get(placePositions.size() - 1);
                if (BlockUtils.place(blockPos, Hand.MAIN_HAND, tnt, rotate.get(), 50, false, false, true)) {
                    placePositions.remove(blockPos);
                    placed = true;
                }

                if (placed) {
                    int preSlot = mc.player.getInventory().selectedSlot;
                    mc.player.getInventory().selectedSlot = fire;
                    mc.interactionManager.interactBlock(mc.player, mc.world, Hand.MAIN_HAND, new BlockHitResult(mc.player.getPos(), Direction.UP, blockPos, true));
                    mc.player.getInventory().selectedSlot = preSlot;
                }
            }

            target = null;
        } else if (mode.get() == Mode.Button) {
            target = TargetUtils.getPlayerTarget(range.get(), SortPriority.LowestDistance);
            if (target == null || mc.player.distanceTo(target) > (float) range.get()) {
                return;
            }

            tnt = InvUtils.findInHotbar(Items.ACACIA_BUTTON, Items.STONE_BUTTON, Items.OAK_BUTTON, Items.SPRUCE_BUTTON, Items.BIRCH_BUTTON, Items.JUNGLE_BUTTON, Items.DARK_OAK_BUTTON, Items.CRIMSON_BUTTON, Items.WARPED_BUTTON).getSlot();
            if (tnt == -1) {
                return;
            }

            placePositionsB.clear();
            findPlacePosB(target);
            if (delay >= Pdelay.get() && placePositionsB.size() > 0) {
                BlockPos BlockPos = placePositionsB.get(placePositionsB.size() - 1);
                if (BlockUtils.place(BlockPos, Hand.MAIN_HAND, tnt, rotate.get(), 50, false, false, true)) {
                    placePositionsB.remove(BlockPos);
                }

                delay = 0;
            } else {
                ++delay;
            }
        }
    }

    private void add(BlockPos blockPos) {
        if (!placePositions.contains(blockPos) && mc.world.getBlockState(blockPos).getMaterial().isReplaceable() && mc.world.canPlace(Blocks.TNT.getDefaultState(), blockPos, ShapeContext.absent())) {
            placePositions.add(blockPos);
        }
    }

    private void addB(BlockPos BlockPos) {
        if (!placePositionsB.contains(BlockPos) && mc.world.getBlockState(BlockPos).getMaterial().isReplaceable() && mc.world.canPlace(Blocks.ACACIA_BUTTON.getDefaultState(), BlockPos, ShapeContext.absent()) && (mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY() + 1, BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY() + 1, BlockPos.getZ())) || mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY() - 1, BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY() - 1, BlockPos.getZ())) || mc.world.getBlockState(new BlockPos(BlockPos.getX() + 1, BlockPos.getY(), BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX() + 1, BlockPos.getY(), BlockPos.getZ())) || mc.world.getBlockState(new BlockPos(BlockPos.getX() - 1, BlockPos.getY(), BlockPos.getZ())).isFullCube(mc.world, new BlockPos(BlockPos.getX() - 1, BlockPos.getY(), BlockPos.getZ())) || mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ() + 1)).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ() + 1)) || mc.world.getBlockState(new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ() - 1)).isFullCube(mc.world, new BlockPos(BlockPos.getX(), BlockPos.getY(), BlockPos.getZ() - 1)))) {
            placePositionsB.add(BlockPos);
        }
    }

    private void findPlacePos(PlayerEntity target) {
        placePositions.clear();
        BlockPos targetPos = target.getBlockPos();
        add(targetPos.add(1, 0, 0));
        add(targetPos.add(0, 0, 1));
        add(targetPos.add(-1, 0, 0));
        add(targetPos.add(0, 0, -1));
    }

    private void findPlacePosB(PlayerEntity target) {
        placePositionsB.clear();
        BlockPos targetPosB = target.getBlockPos();
        addB(targetPosB.add(1, 0, 0));
        addB(targetPosB.add(0, 0, 1));
        addB(targetPosB.add(-1, 0, 0));
        addB(targetPosB.add(0, 0, -1));
    }

    public enum Mode {
        Button,
        TnT
    }
}
